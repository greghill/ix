24d23
< #define IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT 2
131,317d123
< 
< /**
<  * ixgbe_set_ivar - set the IVAR registers, mapping interrupt causes to vectors
<  * @dev: pointer to device
<  * @direction: 0 for Rx, 1 for Tx, -1 for other causes
<  * @queue: queue to map the corresponding interrupt to
<  * @EICRmapping: the bit in the EICR (Extended Interrupt Cause Register) to which want to map
<  * 				 interrupts for this queue
<  * 				 This will also determine which EITR (Extended Interrupt Throttle Register)
<  * 				 controls interrupts for this queue. For ex: if map to bit 0, EITR(0) is used. 
<  **/
< static void ixgbe_set_ivar(struct rte_eth_dev *dev, s8 direction,
< 			   u8 queue, u8 EICRmapping)
< {
< 	u32 ivar, bitshift;
< 	struct ixgbe_hw *hw = IXGBE_DEV_PRIVATE_TO_HW(dev->data->dev_private);
< 
< 	/* 
< 	 * Note: Rx and Tx queue mapping to IVAR registers is as follows:
< 	 * IVAR(0)	IVAR(1)  			IVAR(63)
< 	 * Rx 0		Rx 2				Rx 126
< 	 * Tx 0		Tx 2		...		Tx 126
< 	 * Rx 1		Rx 3				Rx 127
< 	 * Tx 1		Tx 3				Tx 127
< 	 *
< 	 * Therefore, queue number divided by 2 determines appropriate IVAR register
< 	 * Each queue gets 8 bits of the 32 bits in an IVAR register
< 	 * 6 bits for EICR mapping, 1 bit reserved, 1 bit to indicate valid mapping
< 	 *
< 	 */
< 	 if (direction == -1) {
< 		/* other causes */
< 		EICRmapping |= IXGBE_IVAR_ALLOC_VAL;
< 		bitshift = ((queue & 1) * 8);
< 		ivar = IXGBE_READ_REG(hw, IXGBE_IVAR_MISC);
< 		ivar &= ~(0xFF << bitshift);
< 		ivar |= (EICRmapping << bitshift);
< 		IXGBE_WRITE_REG(hw, IXGBE_IVAR_MISC, ivar);
< 	} else {
< 		/* tx or rx causes */
< 		bitshift = ((16 * (queue & 1)) + (8 * direction));		//calculate queue's offset in IVAR
< 		ivar = IXGBE_READ_REG(hw, IXGBE_IVAR(queue >> 1));		
< 		ivar &= ~(0xFF << bitshift); 							//zero out EICR bit mapping
< 		ivar |= (EICRmapping << bitshift); 						//map to EICR bit from function parameter
< 		ivar |= (IXGBE_IVAR_ALLOC_VAL << bitshift); 			//mark mapping as valid
< 		//printf("Writing IVAR for queue %d to value 0x%x\n", queue, ivar);
< 		IXGBE_WRITE_REG(hw, IXGBE_IVAR(queue >> 1), ivar);
< 	}
< }
< 
< /**
<  * ixgbe_write_eitr - write EITR (Extended Interrupt Throttle Register)
<  * @dev: pointer to device
<  * @idx: which EITR register to write, this should depend on IVAR mapping
<  * @itr: interrupt throttle interval (specified in units of 2 us)
<  * 
<  * */
< void ixgbe_write_eitr(struct rte_eth_dev *dev, u8 idx, u32 itr)
< {
< 	struct ixgbe_hw *hw = IXGBE_DEV_PRIVATE_TO_HW(dev->data->dev_private);
< 
< 	switch (hw->mac.type) {
< 	case ixgbe_mac_82598EB:
< 		/* must write high and low 16 bits to reset counter */
< 		itr |= (itr << 16);
< 		break;
< 	case ixgbe_mac_82599EB:
< 	case ixgbe_mac_X540:
< 		/*
< 		 * set the WDIS bit to not clear the timer bits and cause an
< 		 * immediate assertion of the interrupt
< 		 */
< 		itr |= IXGBE_EITR_CNT_WDIS;
< 		break;
< 	default:
< 		break;
< 	}
< 	//printf("Writing EITR for queue %d value 0x%x \n", idx, itr);
< 	IXGBE_WRITE_REG(hw, IXGBE_EITR(idx), itr);
< }
< 
< 
< 
< 
< /*
<  * microsecond values for various ITR rates shifted by 2 to fit itr register
<  * with the first 3 bits reserved 0
<  */
< #define IXGBE_MIN_RSC_ITR_INT	24
< #define IXGBE_100K_ITR_INT		40
< #define IXGBE_20K_ITR_INT		200
< #define IXGBE_10K_ITR_INT		400
< #define IXGBE_8K_ITR_INT		500
< 
< #define IXGBE_EITR_ITR_INT_SHIFT	3
< 
< /**
<  * ixgbe_configure_msix - Configure MSI-X hardware
<  * @dev: pointer to device
<  *
<  * ixgbe_configure_msix sets up the hardware to generate MSI-X
<  * interrupts with desired queue -> EICR bit (and throttle reg) mapping.
<  **/
< static void ixgbe_configure_msix(struct rte_eth_dev *dev)
< {
< 	struct ixgbe_hw *hw;
< 	int i;
< 	u32 mask;
< 
< 	hw = IXGBE_DEV_PRIVATE_TO_HW(dev->data->dev_private);
< 
< 	/*
< 	 * Populate the IVAR registers for all RX queues */
< 	for (i = 0; i < dev->data->nb_rx_queues; i++) {
< 		struct rx_queue *rxq = eth_rx_queue_to_drv(dev->data->rx_queues[i]);
< 		ixgbe_set_ivar(dev, 0, rxq->reg_idx, 0);	
< 	} 
< 
< 	/* FIXME: Add support for interrupt moderation for TX */
< 	
< 	/* 
< 	 * Set appropriate EITR (throttle register) with desired interrupt rate
< 	 * 
< 	 * Currently all queues mapped to bit 0 of EICR
< 	 * so only need to write EITR(0) reg 
< 	 */
< 	ixgbe_write_eitr(dev, 0, IXGBE_100K_ITR_INT);
< 
< 	/* set up to autoclear timer, and the vectors */
< 	mask = IXGBE_EIMS_ENABLE_MASK;
< 	mask &= ~(IXGBE_EIMS_OTHER |
< 		  IXGBE_EIMS_MAILBOX |
< 		  IXGBE_EIMS_LSC);
< 
< 	IXGBE_WRITE_REG(hw, IXGBE_EIAC, mask);
< }
< 
< /** 
<  * ixgbe_setup_gpie - Setup General Purpose Interrupt Enable (GPIE) register
<  * @dev: pointer to device
<  * */
< static void ixgbe_setup_gpie(struct rte_eth_dev *dev)
< {
< 	struct ixgbe_hw *hw = IXGBE_DEV_PRIVATE_TO_HW(dev->data->dev_private);
< 	u32 gpie = 0;
< 
< 	gpie = IXGBE_GPIE_MSIX_MODE | IXGBE_GPIE_PBA_SUPPORT |
< 		IXGBE_GPIE_OCD;
< 
< 	/* 
< 	 * Set RSC Delay
< 	 * Delay = (1 + GPIE.RSC_DELAY) * 4 us  
< 	 */ 
< 	//gpie |= (1 << IXGBE_GPIE_RSC_DELAY_SHIFT);
< 	
< 	gpie |= IXGBE_GPIE_EIAME;
< 	/*
< 	 * use EIAM to auto-mask when MSI-X interrupt is asserted
< 	 * this saves a register write for every interrupt
< 	 */
< 	switch (hw->mac.type) {
< 	  case ixgbe_mac_82598EB:
< 		  IXGBE_WRITE_REG(hw, IXGBE_EIAM, IXGBE_EICS_RTX_QUEUE);
< 		  break;
< 	  case ixgbe_mac_82599EB:
< 	  case ixgbe_mac_X540:
< 	  default:
< 		  IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(0), 0xFFFFFFFF);
< 		  IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(1), 0xFFFFFFFF);
< 		  break;
< 	}
< 
< 	if (hw->mac.type == ixgbe_mac_82599EB) {
< 		gpie |= IXGBE_SDP1_GPIEN;
< 		gpie |= IXGBE_SDP2_GPIEN;
< 	}
< 
< 	IXGBE_WRITE_REG(hw, IXGBE_GPIE, gpie);
< }
< 
< 
< 
< /*
<  * ixgbe_rx_poll - get available pkts from NIC and send for ethernet processing
<  * 				   recycle descriptors (allocate new mbufs and set addr pointers for NIC)
<  * @rx: pointer to rx queue
<  */
367d172
< 
1563d1367
< 		printf("*** jumbo frames enabled\n");
1600c1404,1405
< 				uint32_t psrtype = IXGBE_PSRTYPE_TCPHDR |
---
> 				uint32_t psrtype;
> 				psrtype = IXGBE_PSRTYPE_TCPHDR |
1620d1424
< 
1621a1426
> 
1651,1652d1455
< 		
< 
1654,1657d1456
< 
< 	/* Setup interrupt moderation */
< 	ixgbe_setup_gpie(dev);			//enable interrupts, set RSC_DELAY
< 	ixgbe_configure_msix(dev);		//enable MSI-X
